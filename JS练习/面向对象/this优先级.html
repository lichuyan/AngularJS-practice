<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    /*function foo() {
        console.log( this.a );
    }
    var obj1 = {
        a: 2,
        foo: foo
    };
    var obj2 = {
        a: 3,
        foo: foo
    };
    obj1.foo(); // 2
    obj2.foo(); // 3
    //在该语句中，显式绑定call(obj2)和隐式绑定obj1.foo同时出现，最终结果为3，说明被绑定到了obj2中
    obj1.foo.call( obj2 ); // 3
    obj2.foo.call( obj1 ); // 2*/


    function foo(something) {
        this.a=something;
    }
    var obj1={
        foo:foo
    };
    var obj2={};

    //隐式绑定
    obj1.foo(2);
    console.log(obj1.a); // 2
    console.log(obj1); // {foo: ƒ, a: 2}

    //隐式绑定+显示绑定
    ob1.foo.call(obj2, 3);
    console.log(obj2.a); // 3

    //隐式绑定+new绑定
    // 在下列代码中，隐式绑定obj1.foo和new绑定同时出现。最终obj1.a结果是2，而bar.a结果是4，说明this被绑定在bar上

    var bar = new obj1.foo( 4 );
    console.log( obj1.a ); // 2
    console.log( bar.a ); // 4

    // new 绑定+显示绑定

    //先将obj1绑定到foo函数中，此时this值为obj1
    var bar = foo.bind( obj1 );
    bar( 2 );
    console.log(obj1.a); // 2
    //通过new绑定，此时this值为baz
    var baz = new bar( 3 );
    console.log( obj1.a ); // 2
    //说明使用new绑定时，在bar函数内，无论this指向obj1有没有生效，最终this都指向新创建的对象baz
    console.log( baz.a ); // 3

</script>

</body>
</html>