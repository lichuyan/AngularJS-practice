<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // 原生ajax封装成promise
    function newAjax() {
        return new Promise((reslove,reject)=>{
            var xhr=new XMLHttpRequest();
            xhr.open('get','./data.json',true);
            xhr.onreadystatechange=function () {
                if(xhr.readyState===4&&xhr.status===200){
                    reslove(xhr.responseText);
                }else {
                    if(xhr.readyState==4||xhr.status!==200){
                        reject('error');
                    }
                }
            };
            xhr.send(null);
        })
    }

    newAjax().then(res=>{
        console.log(res);
    }).catch(err=>{
        console.log(err);
    })

    // 利用promise加载异步图片
    function loadImg() {
        return new Promise((resolve,reject)=>{
            var ulr='./niu.jpg';
            var img=document.createElement('img');
            /*img=new Image();*/
            document.body.appendChild(img);
            img.onload=function () {
                resolve(img);
            };
            img.onerror=function () {
                reject('error');
            };
            img.src=ulr;
        })
    }
    loadImg().then((res)=>{
        console.log(res);
    }).catch(err=>{
        console.log(err);
    });

    // 使用promise 来封装jsonp
    /*1.callback函数要绑定在window对象上
    2.服务端返回数据有特定格式要求：callback函数名+'('+JSON.stringify(返回数据) +')'
    3.不支持post，因为js标签本身就是一个get请求*/

    const jsonp = function (url, data) {
        return new Promise((resolve, reject) => {
            // 初始化url
            let dataString = url.indexOf('?') === -1 ? '?' : '&';
            let callbackName = `jsonpCB`;
            url += `${dataString}callback=${callbackName}`;
            if (data) {
                // 有请求参数，依次添加到url
                for (let k in data) {
                    url += `&${k}=${data[k]}`;
                }
            }
            console.log(url);
            // 创建script标签，赋值url
            var jsNode =document.createElement("script");
            jsNode .src=url;

            // 触发callback，触发后删除js标签和绑定在window上的callback
            window[callbackName] = (result=>{
                delete window[callbackName];
                document.body.removeChild(jsNode);
                if (result) {
                    resolve(result)
                } else {
                    reject('没有返回数据')
                }
            })
            // js加载异常的情况
            jsNode.addEventListener('error', () => {
                delete window[callbackName];
                document.body.removeChild(jsNode);
                reject('JavaScript资源加载失败')
            }, false);

            // 添加js节点到document上时，开始请求
            document.body.appendChild(jsNode)
        })
    };
    jsonp('http://192.168.0.103:8081/jsonp', {a: 1, b: 'heiheihei'})
        .then(result => { console.log(result) })
        .catch(err => { console.error(err) });

    console.log(window.jsonpCB);
    console.log(window['jsonpCB']);
    console.log(window);

    // 个人感觉JSONP用的情况还是比较少吧，如果已经是需要服务端配合来进行跨域的情况，为什么不直接用CORS呢

</script>

</body>
</html>